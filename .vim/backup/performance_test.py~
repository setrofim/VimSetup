from __future__ import division
import os
import sys
import shutil
import math
import logging
from datetime import datetime

import numpy as np
import scipy
from scipy import signal
from scipy.stats.stats import pearsonr
import Image
import ImageChops
import pyffmpeg

import rpy2.robjects as robjects
import array
r = robjects.r


def read_frames(stream, step=1):
    """Read frames from a pyffmpeg stream."""
    frameno = 0
    last_pts = -1
    frames = [stream.GetFrameNo(frameno).copy()]
    cur_pts = stream.tv.get_cur_pts()
    while cur_pts != last_pts:
        last_pts = cur_pts
        frameno += step
        logging.debug('getting frame %d' % frameno)
        frames.append(stream.GetFrameNo(frameno).copy())
        cur_pts = stream.tv.get_cur_pts()
    frames.pop(-1)
    return frames


def disassociation(img1, img2):
    """Inverse correlation mapped onto 0.0 to 1.0 space."""
    a1 = np.asarray(img1).flatten()
    a2 = np.asarray(img2).flatten()
    return 1 - (pearsonr(a1, a2)[0] + 1) / 2


def paddedarray(collection, maxlen):
    """ Return numpy array created from the collection. If the collection
    is shorter than maxlen, pad with zeros at the end."""
    if len(collection) <= maxlen:
        return np.array(collection)
    a = np.zeros(maxlen)
    a[0:len(collection)] = collection[:]
    return a


class PerformanceTestConfig(object):

    def __init__(self, framestep=12, fps=240, cacheframes=False, cmpfunc=disassociation):
        # sample every step'th frame from the video stream
        self.step = framestep
        # Recording FPS of the video stream
        self.fps = fps
        # Compoare function. Takes two PIL images as input and returns a float value.
        self.cmpfunc = cmpfunc
        # If true, frame images will be cached by PerformanceTestRun; if false,
        # frames will aways be read from the stream.
        self.cacheframes = cacheframes

DEFAULT_CONFIG = PerformanceTestConfig()


class PerformanceTestRun(object):
    """A single test run recorded on video"""

    def __init__(self, vidfile, config=DEFAULT_CONFIG):
        self.file = vidfile
        self.name = os.path.splitext(os.path.basename(vidfile))[0]
        self.config = config
        self.stream = pyffmpeg.VideoStream()
        self.stream.open(self.file)
        self._framescache = []
        self._reset()

    def _reset(self):
        if self.config.cacheframes:
            self._framescache = list(self._streamframes)
        self.framecount = len(list(self.frames))

    @property
    def frames(self):
        if self.config.cacheframes:
            for frame in self._framescache:
                yield frame
        else: # not self.config.cacheframes
            return self._streamframes

    @property
    def _streamframes(self):
        frameno = 0
        last_pts = -1
        yield self.stream.GetFrameNo(frameno).copy()
        cur_pts = self.stream.tv.get_cur_pts()
        while True:
            last_pts = cur_pts
            frameno += self.step
            frame = self.stream.GetFrameNo(frameno).copy()
            cur_pts = self.stream.tv.get_cur_pts()
            if cur_pts == last_pts:
                break
            yield frame

    def getframe(self, frameno):
        if self.config.cacheframes:
            return self._framescache[frameno]
        else:
            if frameno > self.framecount:
                raise ValueError(('Attempting to access frame number ({}) ' +
                                  'greater than total frame count ({})'
                                 ).format(frameno, self.framecount))
            return self.stream.GetFrameNo(frameno).copy()

    def write_frames(self, framesdir, nameformat='frame_{frameno:04}({realframeno:08}).png'):
        logging.debug('{} writing frames to {}'.format(self.name, framesdir))
        if os.path.isdir(framesdir):
            logging.debug('removing existing directory {}'.format(framesdir))
            shutil.rmtree(framesdir)
        os.makedirs(framesdir)
        for frameno, frame in enumerate(self.frames):
            realframeno = frameno * self.step
            filename = nameformat.format(frameno=frameno, realframeno=realframeno)
            frame.save(os.path.join(framesdir, filename))

    def _read(self):
        frames = read_frames(self.stream, self.config.step)
        if not frames:
            return
        if self.framesdir:
            frames[0].save(os.path.join(self.rawframesdir, 'frame_0000.png'))
        for i in xrange(len(frames)-1):
            logging.debug("%s diffing frames %d and %d" % (self.name, i, i+1))
            frame1, frame2 = frames[i], frames[i+1]
            diffval = self.config.cmpfunc(frame1, frame2)
            self.values.append(diffval)
            if self.framesdir:
                rframedir = os.path.join(self.rawframesdir, 'frame_%04d.png' % (i+1))
                logging.debug('Writing %s' % rframedir)
                frame2.save(rframedir)

    @property
    def rawframesdir(self):
        if self.framesdir:
            return os.path.join(self.framesdir, 'raw_frames')
        else:
            return None

    def getstep(self):
        return self.config.step

    def setstep(self, newstep):
        if self.step != newstep:
            self.config.step = newstep
            self._reset()

    step = property(getstep, setstep)


class TestCase(object):
    """Groups a number of TestRuns for the same case."""

    def __init__(self, casedir, name=None, config=DEFAULT_CONFIG):
        self.name = name if name else os.path.basename(casedir)
        self.path = casedir
        self.config = config
        self.testruns = []
        self._values = None
        if os.path.isdir(self.path):
            self.adddir(self.path)
        else:
            logging.debug("Creating %s", self.path)
            os.makedirs(self.path)

    def adddir(self, path):
        for entry in os.listdir(path):
            if os.path.splitext(entry)[1].lower() in ['.mov']:
                fullpath = os.path.join(path, entry)
                self.addrun(fullpath)

    def addrun(self, filepath):
        logging.debug('Adding run: %s' % fullpath)
        if self.config.saveframes:
            fdir = os.path.join(path, os.path.splitext(filepath)[0])
        else:
            fdir = None
        self.testruns.append(TestRun(fullpath, framesdir=fdir, config=self.config))

    @property
    def values(self):
        if not self._values:
            self._values = []
            maxlen = max(len(r.values) for r in self.testruns)
            for vals in [r.values for r in self.testruns]:
                self._values.append(paddedarray(vals, maxlen))
        return self._values

    def writesummary(self):
        summaryfile = os.path.join(self.path, '.'.join([self.name, 'tsv']))
        if os.path.isfile(summaryfile):
            logging.warning('Overwritting existing summary: %s' % summaryfile)
        with open(summaryfile, 'w') as wfh:
            wfh.write('\t'.join(['run%02d' % (i+1) for i in xrange(len(self.testruns))]))
            wfh.write('\n')
            for row in zip(*self.values):
                wfh.write('\t'.join([str(e) for e in row]))
                wfh.write('\n')

    def plotruns(self):
        plotfile = os.path.join(self.path, '%s-runs.png' % self.name)
        r.png(plotfile,width=2560,height=600*len(self.values))
        r.par(mfrow=array.array('i', [len(self.values),1]))
        for i, vals in enumerate(self.values):
            lv = len(vals)
            x = range(lv)
            r.plot(x, list(vals),
                   xlab="frame", ylab="interest",
                   xaxp=[0, lv, lv],
                   yaxp=[0, math.ceil(max(vals)), math.ceil(max(vals)/0.1)],
                   type="l")
            r.title("run %d" % i)
        r['dev.off']()


if __name__ == '__main__':
    logging.basicConfig(level=logging.DEBUG)
    casedir = sys.argv[1]
    print 'START:', datetime.now().strftime('%H:%M:%S.%f')[:-3]
    if not os.path.isdir(casedir):
        logging.error("Not a valid directory: %s" % casedir)
        sys.exit(2)
    case = TestCase(casedir, name='browser_startup')
    case.writesummary()
    case.plotruns()
    print 'END:', datetime.now().strftime('%H:%M:%S.%f')[:-3]

