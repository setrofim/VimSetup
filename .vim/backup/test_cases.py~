from __future__ import division
import os
import sys
import shutil
import math
import logging
from datetime import datetime

import numpy as np
import scipy
from scipy import signal
from scipy.stats.stats import pearsonr
import Image
import ImageChops
import pyffmpeg

import rpy2.robjects as robjects
import array
r = robjects.r


def read_frames(stream, step=1):
    """Read frames from a pyffmpeg stream."""
    frameno = 0
    last_pts = -1
    frames = [stream.GetFrameNo(frameno).copy()]
    cur_pts = stream.tv.get_cur_pts()
    while cur_pts != last_pts:
        last_pts = cur_pts
        frameno += step
        logging.debug('getting frame %d' % frameno)
        frames.append(stream.GetFrameNo(frameno).copy())
        cur_pts = stream.tv.get_cur_pts()
    frames.pop(-1)
    return frames


def disassociation(img1, img2):
    """Inverse correlation mapped onto 0.0 to 1.0 space."""
    a1 = np.asarray(img1).flatten()
    a2 = np.asarray(img2).flatten()
    return 1 - (pearsonr(a1, a2)[0] + 1) / 2


def paddedarray(collection, maxlen):
    """ Return numpy array created from the collection. If the collection
    is shorter than maxlen, pad with zeros at the end."""
    if len(collection) <= maxlen:
        return np.array(collection)
    a = np.zeros(maxlen)
    a[0:len(collection)] = collection[:]
    return a


class TestConfig(object):

    def __init__(self, framestep=120, fps=240, saveframes=False, cmpfunc=disassociation):
        self.step = framestep
        self.fps = fps
        self.saveframes = saveframes
        self.cmpfunc = cmpfunc

DEFAULT_CONFIG = TestConfig()


class TestRun(object):
    """A single test run recorded on video"""

    def __init__(self, vidfile, config=DEFAULT_CONFIG, framesdir=None):
        self.file = vidfile
        self.name = os.path.splitext(os.path.basename(vidfile))[0]
        if config.saveframes and not framesdir:
            raise Exception("TestRun: saveframes is true but framedir was not specified.")
        self.config = config
        self.framesdir=framesdir
        self.stream = pyffmpeg.VideoStream()
        self.stream.open(self.file)
        self.values = []

        self._setup()
        self._read()

    def _setup(self):
        if self.config.saveframes:
            if os.path.isdir(self.framesdir):
                logging.debug("Removing existing %s" % self.framesdir)
                shutil.rmtree(self.framesdir)
            os.makedirs(self.rawframesdir)

    def _read(self):
        frames = read_frames(self.stream, self.config.step)
        if not frames:
            return
        if self.framesdir:
            frames[0].save(os.path.join(self.rawframesdir, 'frame_0000.png'))
        for i in xrange(len(frames)-1):
            logging.debug("%s diffing frames %d and %d" % (self.name, i, i+1))
            frame1, frame2 = frames[i], frames[i+1]
            diffval = self.config.cmpfunc(frame1, frame2)
            self.values.append(diffval)
            if self.framesdir:
                rframedir = os.path.join(self.rawframesdir, 'frame_%04d.png' % (i+1))
                logging.debug('Writing %s' % rframedir)
                frame2.save(rframedir)

    @property
    def rawframesdir(self):
        if self.framesdir:
            return os.path.join(self.framesdir, 'raw_frames')
        else:
            return None

    def getstep(self):
        return self.config.step

    def setstep(self, newstep):
        oldstep = self.step
        self.config.step = newstep
        if oldstep != newstep:
            self._read()

    step = property(getstep, setstep)


class TestCase(object):
    """Groups a number of TestRuns for the same case."""

    def __init__(self, casedir, name=None, config=DEFAULT_CONFIG):
        self.name = name if name else os.path.basename(casedir)
        self.path = casedir
        self.config = config
        self.testruns = []
        self._values = None
        if os.path.isdir(self.path):
            self.adddir(self.path)
        else:
            logging.debug("Creating %s", self.path)
            os.makedirs(self.path)

    def adddir(self, path):
        for entry in os.listdir(path):
            if os.path.splitext(entry)[1].lower() in ['.mov']:
                fullpath = os.path.join(path, entry)
                self.addrun(fullpath)

    def addrun(self, filepath):
        logging.debug('Adding run: %s' % fullpath)
        if self.config.saveframes:
            fdir = os.path.join(path, os.path.splitext(filepath)[0])
        else:
            fdir = None
        self.testruns.append(TestRun(fullpath, framesdir=fdir, config=self.config))

    @property
    def values(self):
        if not self._values:
            self._values = []
            maxlen = max(len(r.values) for r in self.testruns)
            for vals in [r.values for r in self.testruns]:
                self._values.append(paddedarray(vals, maxlen))
        return self._values

    def writesummary(self):
        summaryfile = os.path.join(self.path, '.'.join([self.name, 'tsv']))
        if os.path.isfile(summaryfile):
            logging.warning('Overwritting existing summary: %s' % summaryfile)
        with open(summaryfile, 'w') as wfh:
            wfh.write('\t'.join(['run%02d' % (i+1) for i in xrange(len(self.testruns))]))
            wfh.write('\n')
            for row in zip(*self.values):
                wfh.write('\t'.join([str(e) for e in row]))
                wfh.write('\n')

    def plotruns(self):
        plotfile = os.path.join(self.path, '%s-runs.png' % self.name)
        r.png(plotfile,width=2560,height=600*len(self.values))
        r.par(mfrow=array.array('i', [len(self.values),1]))
        for i, vals in enumerate(self.values):
            lv = len(vals)
            x = range(lv)
            r.plot(x, list(vals),
                   xlab="frame", ylab="interest",
                   xaxp=[0, lv, lv],
                   yaxp=[0, math.ceil(max(vals)), math.ceil(max(vals)/0.1)],
                   type="l")
            r.title("run %d" % i)
        r['dev.off']()


if __name__ == '__main__':
    logging.basicConfig(level=logging.DEBUG)
    casedir = sys.argv[1]
    print 'START:', datetime.now().strftime('%H:%M:%S.%f')[:-3]
    if not os.path.isdir(casedir):
        logging.error("Not a valid directory: %s" % casedir)
        sys.exit(2)
    case = TestCase(casedir, name='browser_startup')
    case.writesummary()
    case.plotruns()
    print 'END:', datetime.now().strftime('%H:%M:%S.%f')[:-3]

