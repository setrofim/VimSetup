# -*- coding: utf-8 -*-
"""
Created on Fri Jul 08 21:33:11 2011

@author: jakob
"""
import random
import redis

def pairs(l):
    for i in xrange(0, len(l), 2):
        yield l[i:i+2]

class MessageBridge(object):
    def __init__(self):
        self.db = redis.Redis(host='localhost', port=6379)
    
    def forward(self, number):
        """Return the number to forward to, if the number has expired
        or was never in the database to start with it will return the same
        number as it was given. that way you can do
        if number == forward(number):
            add_to_people_for_matching(number)
        else:
            sms(forward(number))"""
        return self.db.get(number) or number
        
    def queue_message(self, message):
        """Queue the messages to be sent out on the phone."""
        self.db.lpush('outbound', message.to_string())
        
    def pull_messages(self):
        """Pull the messages the phone has queued in"""       
        for i in xrange(self.db.llen("inbound")):
            yield self.db.lpop("inbound")

    def pair_expired(self, number):
        """There pair expired, they need to get out of the paired list."""
        self.db.lremove("paired", number)            
    
    def is_new(self, number):
        """If they are not in the users list then they are new"""
        if self.db.lindex("users", number) is None:
            return False
        else:
            return True
            
    def is_paired(self, number):
        """If they are paired then they are in the paired list. 
        NOTE: sometimes they can be paired and not have a partner,
            this is to do with the TTL on the key-values in redis."""
            
        if self.db.lindex("paired", number) is None:
            return False
        else:
            return True
            
    def cleanup(self):
        """Sometimes we need to clean up the paired list to ensure that pairs
        don't float around alone."""
        loners = []
        for i in xrange(self.db.llen("paired")):
            item = self.db.lindex("paired", i)
            if item is None:
                self.db.lrem("paired", item)
                loners.append(item)
        return loners

class Squaredance(object):
    def __init__(self):
        self.people = []
        self.db = redis.Redis(host='localhost', port=6379)
    
    def breakup(self, person):
        """Breaks up a partnership and puts them back in the pool"""
        partner = self.db.get(person)
        self.db.delete(person)
        self.db.delete(partner)
        
        for p in (partner, person):
            self.people.append(p)
      
    def squaredance(self):
        """See if its time for a good old fashioned boogie"""
        if len(self.people) >= 2:
            # <setrofim>
            # self.pairup()
            # </setrofim>
            return self.pairup()
     
    def quit(self, person):
        self.people.remove(person)
        
    def queue(self, person):
        self.people.append(person)
    
    def commit_pair(self, pair):
        """Commit the pair to database and time them out after 45 minutes"""
        p1, p2 = pair
        self.db.set(p1, p2)
        self.db.expire(p1, 2700)
        
        self.db.set(p2, p1)
        self.db.expire(p2, 2700)

    def pairup(self):
        """Make pairs and commit them to the db"""
        random.shuffle(self.people)
        partnerships = list(pairs(self.people))
        
        if len(partnerships[-1]) != 2:
            partnerships.pop() #pop that loser from the list 
        
        for pair in partnerships:
            self.commit_pair(pair) #commit the pair
            for person in pair:
                self.people.remove(person) #remove the pair from people
                self.db.lpush("paired", pair) #update the paired list
        # <setrofim>
        return partenerships
        # </setrofim>
